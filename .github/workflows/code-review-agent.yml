name: Code Review Agent

on:
  pull_request:
    types: [opened, synchronize]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review (used after review-fix push)'
        required: true
        type: string

permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  actions: write
  id-token: write

concurrency:
  group: review-agent-${{ github.event.pull_request.number || inputs.pr_number }}
  cancel-in-progress: true

jobs:
  review:
    name: Review Agent
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout at PR head SHA
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          ref: ${{ github.event.pull_request.head.sha || '' }}
          fetch-depth: 0

      - name: Resolve PR context
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EVENT_NAME: ${{ github.event_name }}
          INPUT_PR: ${{ inputs.pr_number }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          PR_BASE_REF: ${{ github.event.pull_request.base.ref }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            PR_NUM="$INPUT_PR"
            PR_JSON=$(gh pr view "$PR_NUM" --json headRefOid,baseRefName,number)
            HEAD_SHA=$(echo "$PR_JSON" | jq -r '.headRefOid')
            BASE_REF=$(echo "$PR_JSON" | jq -r '.baseRefName')
            git fetch origin "$HEAD_SHA"
            git checkout "$HEAD_SHA"
          else
            HEAD_SHA="$PR_HEAD_SHA"
            BASE_REF="$PR_BASE_REF"
            PR_NUM="$PR_NUMBER"
          fi
          echo "head-sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"
          echo "base-ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
          echo "pr-number=${PR_NUM}" >> "$GITHUB_OUTPUT"

      - name: Determine risk tier
        id: tier
        env:
          BASE_REF: ${{ steps.pr.outputs.base-ref }}
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
        run: |
          if ! git rev-parse --verify "origin/${BASE_REF}" &>/dev/null; then
            git fetch origin "${BASE_REF}" --depth=1 2>/dev/null || true
          fi
          MERGE_BASE="$(git merge-base "origin/${BASE_REF}" HEAD 2>/dev/null || echo "")"
          if [[ -z "$MERGE_BASE" ]]; then
            echo "tier=3" >> "$GITHUB_OUTPUT"
            echo "changed-files=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          CHANGED="$(git diff --name-only "${MERGE_BASE}...HEAD" 2>/dev/null || echo "")"
          if [[ -z "$CHANGED" ]]; then
            echo "tier=1" >> "$GITHUB_OUTPUT"
            echo "changed-files=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          TIER=1
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            case "$file" in
              src/index.ts|package.json|tsconfig.json|vitest.config.ts|eslint.config.js)
                TIER=3 ;;
              src/*.ts|tests/*.ts|scripts/*.ts)
                [[ $TIER -lt 2 ]] && TIER=2 ;;
            esac
          done <<< "$CHANGED"
          echo "tier=${TIER}" >> "$GITHUB_OUTPUT"
          {
            echo "changed-files<<CEOF"
            echo "$CHANGED"
            echo "CEOF"
          } >> "$GITHUB_OUTPUT"
          echo "Tier ${TIER} — $(echo "$CHANGED" | wc -l) files changed"

      - name: Skip if Tier 1
        if: steps.tier.outputs.tier == '1'
        run: echo "Tier 1 change — review agent not required."

      - name: SHA deduplication check
        if: steps.tier.outputs.tier != '1'
        id: dedup
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}
        with:
          script: |
            const headSha = process.env.HEAD_SHA;
            const marker = `<!-- harness-review: ${headSha} -->`;
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });
            const alreadyReviewed = comments.some((c) => c.body?.includes(marker));
            if (alreadyReviewed) {
              core.info(`SHA ${headSha.slice(0, 12)} already reviewed — skipping.`);
              core.setOutput('skip', 'true');
            } else {
              core.setOutput('skip', 'false');
            }

      - name: Setup Node.js
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        run: npm ci

      - name: Read review prompt
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: prompt-file
        run: |
          if [[ -f ".codefactory/prompts/review-agent.md" ]]; then
            {
              echo "content<<PROMPT_EOF"
              cat .codefactory/prompts/review-agent.md
              echo "PROMPT_EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "content=Review this pull request for bugs, security issues, and architectural violations." >> "$GITHUB_OUTPUT"
          fi

      - name: Build review prompt
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: build-prompt
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          REVIEW_TEMPLATE: ${{ steps.prompt-file.outputs.content }}
          TIER: ${{ steps.tier.outputs.tier }}
          CHANGED_FILES: ${{ steps.tier.outputs.changed-files }}
        with:
          script: |
            const fs = require('fs');
            const template = process.env.REVIEW_TEMPLATE || '';
            const tier = process.env.TIER || '2';
            const changedFiles = process.env.CHANGED_FILES || '';
            let conventions = '';
            try { conventions = fs.readFileSync('KIRO.md', 'utf-8').slice(0, 6000); } catch {}
            let config = '';
            try { config = fs.readFileSync('harness.config.json', 'utf-8'); } catch {}

            const sections = [
              template,
              '',
              '## PR Context',
              '',
              `**Risk Tier**: Tier ${tier}`,
              '**Changed Files**:',
              changedFiles ? changedFiles.split('\n').map(f => `- ${f}`).join('\n') : '*(none detected)*',
              '',
              '## Project Conventions (from KIRO.md)',
              '',
              conventions || 'No KIRO.md found.',
              '',
              '## Harness Configuration',
              '',
              '```json',
              config || '{}',
              '```',
            ];
            const prompt = sections.join('\n');
            core.setOutput('prompt', prompt);
            core.info(`Review prompt built (${prompt.length} chars)`);

      - name: Configure AWS credentials
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        uses: aws-actions/configure-aws-credentials@v4
        continue-on-error: true
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Setup Kiro CLI
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        uses: clouatre-labs/setup-kiro-action@v1
        with:
          enable-sigv4: 'true'

      - name: Authenticate Kiro CLI
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        env:
          KIRO_CLIENT_ID: ${{ secrets.KIRO_CLIENT_ID }}
          KIRO_CLIENT_SECRET: ${{ secrets.KIRO_CLIENT_SECRET }}
          KIRO_REFRESH_TOKEN: ${{ secrets.KIRO_REFRESH_TOKEN }}
          KIRO_PROFILE_ARN: ${{ secrets.KIRO_PROFILE_ARN }}
          KIRO_START_URL: ${{ secrets.KIRO_START_URL || '' }}
          AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
        run: |
          RESPONSE=$(curl -s -X POST \
            "https://oidc.${AWS_REGION}.amazonaws.com/token" \
            -H "Content-Type: application/json" \
            -d "{
              \"grantType\": \"refresh_token\",
              \"clientId\": \"${KIRO_CLIENT_ID}\",
              \"clientSecret\": \"${KIRO_CLIENT_SECRET}\",
              \"refreshToken\": \"${KIRO_REFRESH_TOKEN}\"
            }")
          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.accessToken // empty')
          NEW_REFRESH=$(echo "$RESPONSE" | jq -r '.refreshToken // empty')
          if [[ -z "$ACCESS_TOKEN" ]]; then
            echo "::error::Kiro OIDC token refresh failed"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
            exit 1
          fi
          echo "::add-mask::${ACCESS_TOKEN}"
          echo "::add-mask::${NEW_REFRESH}"
          mkdir -p ~/.local/share/kiro-cli
          EXPIRES_AT=$(date -u -d "+3600 seconds" +"%Y-%m-%dT%H:%M:%S.%6NZ")
          CLIENT_EXPIRES=$(date -u -d "+90 days" +"%Y-%m-%dT%H:%M:%S.000Z")
          python3 -c "
          import sqlite3, json, sys, os, time
          db = os.path.expanduser('~/.local/share/kiro-cli/data.sqlite3')
          conn = sqlite3.connect(db)
          c = conn.cursor()
          c.executescript('''
            CREATE TABLE IF NOT EXISTS migrations (
              id INTEGER PRIMARY KEY, version INTEGER NOT NULL,
              migration_time INTEGER NOT NULL);
            CREATE TABLE IF NOT EXISTS auth_kv (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS state (
              key TEXT PRIMARY KEY, value BLOB);
            CREATE TABLE IF NOT EXISTS history (
              id INTEGER PRIMARY KEY);
            CREATE TABLE IF NOT EXISTS conversations (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS conversations_v2 (
              key TEXT NOT NULL, conversation_id TEXT NOT NULL,
              value TEXT NOT NULL, created_at INTEGER NOT NULL,
              updated_at INTEGER NOT NULL,
              PRIMARY KEY (key, conversation_id));
          ''')
          now = int(time.time())
          for i in range(9):
            c.execute('INSERT OR IGNORE INTO migrations VALUES (?,?,?)', (i+1,i,now))
          token = json.dumps({'access_token': sys.argv[1], 'expires_at': sys.argv[2],
            'refresh_token': sys.argv[3], 'region': sys.argv[6],
            'start_url': sys.argv[7] or '', 'oauth_flow': 'Pkce',
            'scopes': ['codewhisperer:completions','codewhisperer:analysis','codewhisperer:conversations']})
          reg = json.dumps({'client_id': sys.argv[4], 'client_secret': sys.argv[5],
            'client_secret_expires_at': sys.argv[8], 'region': sys.argv[6],
            'oauth_flow': 'Pkce', 'scopes': ['codewhisperer:completions',
            'codewhisperer:analysis','codewhisperer:conversations']})
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:token', token))
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:device-registration', reg))
          if sys.argv[9]:
            profile = json.dumps({'arn': sys.argv[9], 'profile_name': sys.argv[9].split('/')[-1]})
            c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('api.codewhisperer.profile', profile))
          c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('profile.Migrated', '1'))
          conn.commit()
          conn.close()
          " "$ACCESS_TOKEN" "$EXPIRES_AT" "$NEW_REFRESH" \
            "$KIRO_CLIENT_ID" "$KIRO_CLIENT_SECRET" "$AWS_REGION" \
            "$KIRO_START_URL" "$CLIENT_EXPIRES" "$KIRO_PROFILE_ARN"
          kiro-cli-chat whoami

      - name: Run AI review
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: ai-review
        continue-on-error: true
        env:
          KIRO_PROMPT: ${{ steps.build-prompt.outputs.prompt }}
        run: |
          RAW=$(kiro-cli-chat chat --no-interactive --trust-all-tools "$KIRO_PROMPT" 2>&1) || true
          CLEAN=$(printf '%s\n' "$RAW" | sed 's/\x1b\[[0-9;]*m//g')
          echo "$CLEAN"
          {
            echo "output<<KIRO_OUTPUT_EOF"
            echo "$CLEAN"
            echo "KIRO_OUTPUT_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Extract review output
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: extract
        env:
          FINAL_MESSAGE: ${{ steps.ai-review.outputs.output }}
        run: |
          REVIEW_TEXT="$FINAL_MESSAGE"
          if [[ -z "$REVIEW_TEXT" || "$REVIEW_TEXT" == "null" ]]; then
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Could not extract review text"
          else
            REVIEW_TEXT="${REVIEW_TEXT:0:60000}"
            {
              echo "review<<REVIEW_EOF"
              echo "$REVIEW_TEXT"
              echo "REVIEW_EOF"
            } >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "Extracted review ($(echo "$REVIEW_TEXT" | wc -c) chars)"
          fi

      - name: Post review comment
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          REVIEW_TEXT: ${{ steps.extract.outputs.review || '' }}
          REVIEW_FOUND: ${{ steps.extract.outputs.found || 'false' }}
          REVIEW_OUTCOME: ${{ steps.ai-review.outcome }}
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}
          TIER: ${{ steps.tier.outputs.tier }}
        with:
          script: |
            const headSha = process.env.HEAD_SHA;
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const marker = `<!-- harness-review: ${headSha} -->`;
            const tier = process.env.TIER;
            const reviewText = process.env.REVIEW_TEXT || '';
            const reviewFound = process.env.REVIEW_FOUND === 'true';
            const reviewOutcome = process.env.REVIEW_OUTCOME || 'failure';

            const sections = [
              marker,
              `## Code Review Agent — Tier ${tier}`,
              '',
              `**Commit**: \`${headSha.slice(0, 12)}\``,
              `**Status**: ${reviewOutcome === 'success' ? 'Complete' : 'Review may be incomplete'}`,
            ];

            if (reviewFound && reviewText) {
              sections.push('', reviewText);
            } else {
              sections.push('', '*No review output was produced. The review agent may have encountered an error.*');
            }

            sections.push('', '---', '*Code Review Agent — automated code review.*');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: sections.join('\n'),
            });
