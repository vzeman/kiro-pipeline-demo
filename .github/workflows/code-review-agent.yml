name: Code Review Agent
on:
  pull_request:
    types: [opened, synchronize]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review (used after review-fix push)'
        required: true
        type: string
permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write
  actions: write
  id-token: write
concurrency:
  group: review-agent-${{ github.event.pull_request.number || inputs.pr_number }}
  cancel-in-progress: true
jobs:
  review:
    name: Review Agent
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout at PR head SHA
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          ref: ${{ github.event.pull_request.head.sha || '' }}
          fetch-depth: 0
      - name: Resolve PR context
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EVENT_NAME: ${{ github.event_name }}
          INPUT_PR: ${{ inputs.pr_number }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          PR_BASE_REF: ${{ github.event.pull_request.base.ref }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            PR_NUM="$INPUT_PR"
            PR_JSON=$(gh pr view "$PR_NUM" --json headRefOid,baseRefName,number)
            HEAD_SHA=$(echo "$PR_JSON" | jq -r '.headRefOid')
            BASE_REF=$(echo "$PR_JSON" | jq -r '.baseRefName')
            git fetch origin "$HEAD_SHA"
            git checkout "$HEAD_SHA"
            echo "‚úî Resolved PR #${PR_NUM} at ${HEAD_SHA:0:12} (workflow_dispatch)"
          else
            HEAD_SHA="$PR_HEAD_SHA"
            BASE_REF="$PR_BASE_REF"
            PR_NUM="$PR_NUMBER"
          fi
          echo "head-sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"
          echo "base-ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
          echo "pr-number=${PR_NUM}" >> "$GITHUB_OUTPUT"
      - name: Determine risk tier
        id: tier
        env:
          BASE_REF: ${{ steps.pr.outputs.base-ref }}
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
        run: |
          ACTUAL_SHA="$(git rev-parse HEAD)"
          if [[ "${ACTUAL_SHA,,}" != "${HEAD_SHA,,}" ]]; then
            echo "::error::SHA discipline violation: HEAD (${ACTUAL_SHA}) ‚â† expected (${HEAD_SHA})"
            exit 1
          fi
          if ! git rev-parse --verify "origin/${BASE_REF}" &>/dev/null; then
            git fetch origin "${BASE_REF}" --depth=1 2>/dev/null || true
          fi
          MERGE_BASE="$(git merge-base "origin/${BASE_REF}" HEAD 2>/dev/null || echo "")"
          if [[ -z "$MERGE_BASE" ]]; then
            echo "tier=3" >> "$GITHUB_OUTPUT"
            echo "changed-files=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          CHANGED="$(git diff --name-only "${MERGE_BASE}...HEAD" 2>/dev/null || echo "")"
          if [[ -z "$CHANGED" ]]; then
            echo "tier=1" >> "$GITHUB_OUTPUT"
            echo "changed-files=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          TIER=1
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            case "$file" in
              src/index.ts|src/cli.ts|package.json|tsconfig.json|vitest.config.ts|eslint.config.js)
                TIER=3 ;;
              src/*.ts|tests/*.ts|scripts/*.ts|*.ts|*.js)
                [[ $TIER -lt 2 ]] && TIER=2 ;;
            esac
          done <<< "$CHANGED"
          echo "tier=${TIER}" >> "$GITHUB_OUTPUT"
          {
            echo "changed-files<<CEOF"
            echo "$CHANGED"
            echo "CEOF"
          } >> "$GITHUB_OUTPUT"
          echo "‚úî Tier ${TIER} ‚Äî $(echo "$CHANGED" | wc -l) files changed"
      - name: Skip if Tier 1
        if: steps.tier.outputs.tier == '1'
        run: echo "Tier 1 change ‚Äî review agent not required. Skipping."
      - name: Notify PR ‚Äî review agent skipped (Tier 1)
        if: steps.tier.outputs.tier == '1'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}
        with:
          script: |
            const headSha = process.env.HEAD_SHA;
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const marker = `<!-- harness-tier1-skip: ${headSha} -->`;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });
            if (comments.some((c) => c.body?.includes(marker))) {
              core.info(`Tier 1 skip notification already posted for SHA ${headSha.slice(0, 12)} ‚Äî skipping.`);
              return;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: [
                marker,
                `## ‚ÑπÔ∏è Review Agent ‚Äî Skipped (Tier 1)`,
                '',
                `**Commit**: \`${headSha.slice(0, 12)}\``,
                `**Tier**: 1 (low risk ‚Äî documentation / non-code changes)`,
                '',
                'This pull request only touches **Tier 1** files (documentation, configuration cosmetics, non-code assets). The automated code review agent does not run for Tier 1 changes ‚Äî they are considered low-risk and only require lint checks.',
                '',
                'If this PR should be reviewed, you can manually trigger the review workflow from the **Actions** tab.',
                '',
                '---',
                '*ü§ñ Code Review Agent ‚Äî automated code review.*',
              ].join('\n'),
            });
            core.info(`Posted Tier 1 skip notification for SHA ${headSha.slice(0, 12)}.`);
      - name: SHA deduplication check
        if: steps.tier.outputs.tier != '1'
        id: dedup
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}
        with:
          script: |
            const headSha = process.env.HEAD_SHA;
            const marker = `<!-- harness-review: ${headSha} -->`;
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            core.info(`Checking for existing review of SHA ${headSha.slice(0, 12)}...`);
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });
            const alreadyReviewed = comments.some((c) => c.body?.includes(marker));
            if (alreadyReviewed) {
              core.info(`SHA ${headSha.slice(0, 12)} already reviewed ‚Äî skipping.`);
              core.setOutput('skip', 'true');
            } else {
              core.info(`No existing review for SHA ${headSha.slice(0, 12)} ‚Äî proceeding.`);
              core.setOutput('skip', 'false');
            }
      - name: Create in-progress check run
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: check
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
        with:
          script: |
            const headSha = process.env.HEAD_SHA;
            const { data: checkRun } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'review-agent',
              head_sha: headSha,
              status: 'in_progress',
              started_at: new Date().toISOString(),
              output: {
                title: 'Code Review Agent',
                summary: 'Review in progress...',
              },
            });
            core.setOutput('check-run-id', checkRun.id);
            core.info(`Created check run ${checkRun.id} for SHA ${headSha.slice(0, 12)}`);
      - name: Read review prompt
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: prompt-file
        run: |
          PROMPT_CONTENT=$(git show origin/main:.codefactory/prompts/review-agent.md 2>/dev/null || echo "")
          if [[ -n "$PROMPT_CONTENT" ]]; then
            {
              echo "content<<PROMPT_EOF"
              echo "$PROMPT_CONTENT"
              echo "PROMPT_EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "content=Review this pull request for bugs, security issues, and architectural violations." >> "$GITHUB_OUTPUT"
          fi
      - name: Build review prompt
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: build-prompt
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          REVIEW_TEMPLATE: ${{ steps.prompt-file.outputs.content }}
          TIER: ${{ steps.tier.outputs.tier }}
          CHANGED_FILES: ${{ steps.tier.outputs.changed-files }}
        with:
          script: |
            const fs = require('fs');
            const template = process.env.REVIEW_TEMPLATE || '';
            const tier = process.env.TIER || '2';
            const changedFiles = process.env.CHANGED_FILES || '';
            let conventions = '';
            try { conventions = fs.readFileSync('KIRO.md', 'utf-8').slice(0, 6000); } catch {}
            let config = '';
            try { config = fs.readFileSync('harness.config.json', 'utf-8'); } catch {}
            const sections = [
              template,
              '',
              '## PR Context',
              '',
              `**Risk Tier**: Tier ${tier}`,
              `**Changed Files**:`,
              changedFiles ? changedFiles.split('\n').map(f => `- ${f}`).join('\n') : '*(none detected)*',
              '',
              '## Project Conventions (from KIRO.md)',
              '',
              conventions || 'No KIRO.md found.',
              '',
              '## Harness Configuration',
              '',
              'json',
             config || '{}',
             '',
            ];
            const prompt = sections.join('\n');
            core.setOutput('prompt', prompt);
            core.info(Review prompt built (${prompt.length} chars));
      - name: Configure AWS credentials
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        uses: aws-actions/configure-aws-credentials@v4
        continue-on-error: true
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
      - name: Setup Kiro CLI
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        uses: clouatre-labs/setup-kiro-action@v1
        with:
          enable-sigv4: 'true'
      - name: Authenticate Kiro CLI
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        env:
          KIRO_CLIENT_ID: ${{ secrets.KIRO_CLIENT_ID }}
          KIRO_CLIENT_SECRET: ${{ secrets.KIRO_CLIENT_SECRET }}
          KIRO_REFRESH_TOKEN: ${{ secrets.KIRO_REFRESH_TOKEN }}
          KIRO_PROFILE_ARN: ${{ secrets.KIRO_PROFILE_ARN }}
          KIRO_START_URL: ${{ secrets.KIRO_START_URL || '' }}
          AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
        run: |
          RESPONSE=$(curl -s -X POST \
            "https://oidc.${AWS_REGION}.amazonaws.com/token" \
            -H "Content-Type: application/json" \
            -d "{
              \"grantType\": \"refresh_token\",
              \"clientId\": \"${KIRO_CLIENT_ID}\",
              \"clientSecret\": \"${KIRO_CLIENT_SECRET}\",
              \"refreshToken\": \"${KIRO_REFRESH_TOKEN}\"
            }")
          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.accessToken // empty')
          NEW_REFRESH=$(echo "$RESPONSE" | jq -r '.refreshToken // empty')
          if [[ -z "$ACCESS_TOKEN" ]]; then
            echo "::error::Kiro OIDC token refresh failed"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
            exit 1
          fi
          echo "::add-mask::${ACCESS_TOKEN}"
          echo "::add-mask::${NEW_REFRESH}"
          mkdir -p ~/.local/share/kiro-cli
          EXPIRES_AT=$(date -u -d "+3600 seconds" +"%Y-%m-%dT%H:%M:%S.%6NZ")
          CLIENT_EXPIRES=$(date -u -d "+90 days" +"%Y-%m-%dT%H:%M:%S.000Z")
          python3 -c "
          import sqlite3, json, sys, os, time
          db = os.path.expanduser('~/.local/share/kiro-cli/data.sqlite3')
          conn = sqlite3.connect(db)
          c = conn.cursor()
          c.executescript('''
            CREATE TABLE IF NOT EXISTS migrations (
              id INTEGER PRIMARY KEY, version INTEGER NOT NULL,
              migration_time INTEGER NOT NULL);
            CREATE TABLE IF NOT EXISTS auth_kv (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS state (
              key TEXT PRIMARY KEY, value BLOB);
            CREATE TABLE IF NOT EXISTS history (
              id INTEGER PRIMARY KEY);
            CREATE TABLE IF NOT EXISTS conversations (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS conversations_v2 (
              key TEXT NOT NULL, conversation_id TEXT NOT NULL,
              value TEXT NOT NULL, created_at INTEGER NOT NULL,
              updated_at INTEGER NOT NULL,
              PRIMARY KEY (key, conversation_id));
          ''')
          now = int(time.time())
          for i in range(9):
            c.execute('INSERT OR IGNORE INTO migrations VALUES (?,?,?)', (i+1,i,now))
          token = json.dumps({'access_token': sys.argv[1], 'expires_at': sys.argv[2],
            'refresh_token': sys.argv[3], 'region': sys.argv[6],
            'start_url': sys.argv[7] or '', 'oauth_flow': 'Pkce',
            'scopes': ['codewhisperer:completions','codewhisperer:analysis','codewhisperer:conversations']})
          reg = json.dumps({'client_id': sys.argv[4], 'client_secret': sys.argv[5],
            'client_secret_expires_at': sys.argv[8], 'region': sys.argv[6],
            'oauth_flow': 'Pkce', 'scopes': ['codewhisperer:completions',
            'codewhisperer:analysis','codewhisperer:conversations']})
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:token', token))
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:device-registration', reg))
          if sys.argv[9]:
            profile = json.dumps({'arn': sys.argv[9], 'profile_name': sys.argv[9].split('/')[-1]})
            c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('api.codewhisperer.profile', profile))
          c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('profile.Migrated', '1'))
          conn.commit()
          conn.close()
          " "$ACCESS_TOKEN" "$EXPIRES_AT" "$NEW_REFRESH" \
            "$KIRO_CLIENT_ID" "$KIRO_CLIENT_SECRET" "$AWS_REGION" \
            "$KIRO_START_URL" "$CLIENT_EXPIRES" "$KIRO_PROFILE_ARN"
          kiro-cli-chat whoami
      - name: Run agent
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: agent
        continue-on-error: true
        env:
          KIRO_PROMPT: ${{ steps.build-prompt.outputs.prompt }}
        run: |
          RAW=$(kiro-cli-chat chat --no-interactive --trust-all-tools "$KIRO_PROMPT" 2>&1) || true
          CLEAN=$(printf '%s\n' "$RAW" | sed 's/\x1b\[[0-9;]*m//g')
          echo "$CLEAN"
          {
            echo "output<<KIRO_OUTPUT_EOF"
            echo "$CLEAN"
            echo "KIRO_OUTPUT_EOF"
          } >> "$GITHUB_OUTPUT"
      - name: Extract review output
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: extract
        env:
          FINAL_MESSAGE: ${{ steps.agent.outputs.output }}
        run: |
          REVIEW_TEXT="$FINAL_MESSAGE"
          if [[ -z "$REVIEW_TEXT" || "$REVIEW_TEXT" == "null" ]]; then
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Could not extract review text"
          else
            REVIEW_TEXT="${REVIEW_TEXT:0:60000}"
            {
              echo "review<<REVIEW_EOF"
              echo "$REVIEW_TEXT"
              echo "REVIEW_EOF"
            } >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "‚úî Extracted review ($(echo "$REVIEW_TEXT" | wc -c) chars)"
          fi
      - name: Post review comment
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: post-review
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          REVIEW_TEXT: ${{ steps.extract.outputs.review || '' }}
          REVIEW_FOUND: ${{ steps.extract.outputs.found || 'false' }}
          REVIEW_OUTCOME: ${{ steps.agent.outcome }}
          HEAD_SHA: ${{ steps.pr.outputs.head-sha }}
          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}
          TIER: ${{ steps.tier.outputs.tier }}
        with:
          script: |
            const headSha = process.env.HEAD_SHA;
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const marker = <!-- harness-review: ${headSha} -->;
            const tier = process.env.TIER;
            const reviewText = process.env.REVIEW_TEXT || '';
            const reviewFound = process.env.REVIEW_FOUND === 'true';
            const reviewOutcome = process.env.REVIEW_OUTCOME || 'failure';
            const sections = [
              marker,
              ## üîç Code Review Agent ‚Äî Tier ${tier},
              '',
              **Commit**: \${headSha.slice(0, 12)}\,
              **Status**: ${reviewOutcome === 'success' ? '‚úÖ Complete' : '‚ö†Ô∏è Review may be incomplete'},
            ];
            if (reviewFound && reviewText) {
              sections.push('', reviewText);
            } else {
              sections.push('', '*No review output was produced. The review agent may have encountered an error.*');
            }
            sections.push('', '---', '*ü§ñ Code Review Agent ‚Äî automated code review.*');
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: sections.join('\n'),
            });
            core.setOutput('comment-id', comment.id);
      - name: Run verdict classifier
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true' && steps.extract.outputs.found == 'true'
        id: classifier
        continue-on-error: true
        env:
          KIRO_PROMPT: ${{ format('Read the following code review and classify the verdict.\n\nRules:\n- APPROVE: The review found no blocking issues. The code is safe to merge.\n- REQUEST_CHANGES: The review found one or more blocking issues (security vulnerabilities, bugs that cause runtime errors, data loss, or crashes). Only blocking issues warrant REQUEST_CHANGES ‚Äî warnings and suggestions do not.\n- COMMENT: The review found warnings or suggestions but no blocking issues, OR the review is unclear.\n\n<review>\n{0}\n</review>', steps.extract.outputs.review) }}
        run: |
          RAW=$(kiro-cli-chat chat --no-interactive --trust-all-tools "$KIRO_PROMPT" 2>&1) || true
          CLEAN=$(printf '%s\n' "$RAW" | sed 's/\x1b\[[0-9;]*m//g')
          echo "$CLEAN"
          {
            echo "output<<KIRO_CLASSIFIER_EOF"
            echo "$CLEAN"
            echo "KIRO_CLASSIFIER_EOF"
          } >> "$GITHUB_OUTPUT"
      - name: Extract verdict
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true'
        id: verdict
        env:
          CLASSIFIER_OUTPUT: ${{ steps.classifier.outputs.output || '' }}
          CLASSIFIER_OUTCOME: ${{ steps.classifier.outcome || 'failure' }}
        run: |
          VERDICT="COMMENT"
          if [[ "$CLASSIFIER_OUTCOME" != "success" ]]; then
            echo "::notice::Verdict classifier failed ‚Äî defaulting to COMMENT."
            echo "verdict=COMMENT" >> "$GITHUB_OUTPUT"
            echo "reason=Classifier failed" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [[ -n "$CLASSIFIER_OUTPUT" ]]; then
            if echo "$CLASSIFIER_OUTPUT" | grep -qi "APPROVE"; then
              VERDICT="APPROVE"
            elif echo "$CLASSIFIER_OUTPUT" | grep -qi "REQUEST_CHANGES"; then
              VERDICT="REQUEST_CHANGES"
            fi
          fi
          echo "verdict=${VERDICT}" >> "$GITHUB_OUTPUT"
          echo "reason=Extracted from classifier output" >> "$GITHUB_OUTPUT"
          echo "Verdict: ${VERDICT}"
      - name: Update review comment with verdict
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true' && steps.post-review.outputs.comment-id
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          COMMENT_ID: ${{ steps.post-review.outputs.comment-id }}
          VERDICT: ${{ steps.verdict.outputs.verdict || 'COMMENT' }}
          VERDICT_REASON: ${{ steps.verdict.outputs.reason || '' }}
        with:
          script: |
            const commentId = parseInt(process.env.COMMENT_ID);
            const verdict = process.env.VERDICT || 'COMMENT';
            const reason = process.env.VERDICT_REASON || '';
            const verdictMarker = <!-- review-verdict: ${verdict} -->;
            const verdictEmoji = verdict === 'APPROVE' ? '‚úÖ' : verdict === 'REQUEST_CHANGES' ? 'üîÑ' : 'üí¨';
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            let body = comment.body || '';
            const lines = body.split('\n');
            const insertIdx = lines.findIndex(l => l.startsWith('<!-- harness-review:'));
            if (insertIdx !== -1) {
              lines.splice(insertIdx + 1, 0, verdictMarker);
            } else {
              lines.unshift(verdictMarker);
            }
            const statusIdx = lines.findIndex(l => l.startsWith('**Status**'));
            if (statusIdx !== -1) {
              const verdictLine = **Verdict**: ${verdictEmoji} ${verdict}${reason ?  ‚Äî ${reason} : ''};
              lines.splice(statusIdx + 1, 0, verdictLine);
            }
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: lines.join('\n'),
            });
            core.info(Updated review comment with verdict: ${verdict});
      - name: Complete check run
        if: always() && steps.check.outputs.check-run-id
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          CHECK_RUN_ID: ${{ steps.check.outputs.check-run-id }}
          REVIEW_OUTCOME: ${{ steps.agent.outcome }}
        with:
          script: |
            const checkRunId = parseInt(process.env.CHECK_RUN_ID);
            const reviewOutcome = process.env.REVIEW_OUTCOME || 'failure';
            const conclusion = reviewOutcome === 'success' ? 'success' : 'neutral';
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'completed',
              conclusion,
              completed_at: new Date().toISOString(),
              output: {
                title: Review Agent ‚Äî ${conclusion === 'success' ? 'Complete' : 'Review Needed'},
                summary: AI code review completed with outcome: ${reviewOutcome},
              },
            });
            core.info(Check run ${checkRunId} completed: ${conclusion});
      - name: Check review-fix eligibility
        if: steps.tier.outputs.tier != '1' && steps.dedup.outputs.skip != 'true' && steps.verdict.outputs.verdict == 'REQUEST_CHANGES'
        id: review-fix
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            const prLabels = pr.labels.map(l => l.name);
            if (!prLabels.includes('agent-pr')) {
              core.info('PR does not have agent-pr label ‚Äî skipping review-fix dispatch.');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Not an agent-created PR');
              return;
            }
            if (prLabels.includes('agent:needs-judgment')) {
              core.info('PR already has agent:needs-judgment label ‚Äî skipping.');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Already escalated');
              return;
            }
            let maxCycle = 0;
            for (const label of prLabels) {
              const match = label.match(/^review-fix-cycle-(\d+)$/);
              if (match) {
                const n = parseInt(match[1], 10);
                if (n > maxCycle) maxCycle = n;
              }
            }
            const nextCycle = maxCycle + 1;
            if (nextCycle > 3) {
              core.info(Max review-fix cycles reached (${maxCycle} cycles). Escalating.);
              core.setOutput('eligible', 'false');
              core.setOutput('escalate', 'true');
              core.setOutput('reason', Max cycles exceeded (${maxCycle}));
              return;
            }
            const prBody = pr.body || '';
            const issueMatch = prBody.match(/<!-- issue-implementer: #(\d+) -->/);
            const issueNumber = issueMatch ? issueMatch[1] : '';
            core.setOutput('eligible', 'true');
            core.setOutput('escalate', 'false');
            core.setOutput('cycle', String(nextCycle));
            core.setOutput('issue-number', issueNumber);
            core.info(Review-fix eligible: cycle ${nextCycle}, issue #${issueNumber || 'unknown'}
