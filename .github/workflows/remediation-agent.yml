name: Remediation Agent

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: PR number to remediate
        required: true
        type: number
      head_sha:
        description: Commit SHA to fix against (SHA discipline)
        required: true
        type: string
      findings:
        description: JSON array of actionable review findings
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  id-token: write

concurrency:
  group: remediation-${{ inputs.pr_number }}
  cancel-in-progress: false

jobs:
  remediate:
    name: Remediation Agent
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Get PR branch info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          PR_JSON=$(gh pr view "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --json headRefName,headRefOid,state)
          BRANCH=$(echo "$PR_JSON" | jq -r '.headRefName')
          CURRENT_SHA=$(echo "$PR_JSON" | jq -r '.headRefOid')
          STATE=$(echo "$PR_JSON" | jq -r '.state')

          if [[ "$STATE" != "OPEN" ]]; then
            echo "::error::PR #${PR_NUMBER} is ${STATE}, not OPEN. Aborting."
            exit 1
          fi

          echo "branch=${BRANCH}" >> "$GITHUB_OUTPUT"
          echo "current-sha=${CURRENT_SHA}" >> "$GITHUB_OUTPUT"

      - name: SHA discipline check
        env:
          CURRENT_SHA: ${{ steps.pr-info.outputs.current-sha }}
          EXPECTED_SHA: ${{ inputs.head_sha }}
        run: |
          if [[ "${CURRENT_SHA,,}" != "${EXPECTED_SHA,,}" ]]; then
            echo "::error::SHA discipline violation: PR HEAD (${CURRENT_SHA}) ‚â† expected (${EXPECTED_SHA}). Branch was updated since dispatch."
            exit 1
          fi
          echo "‚úî SHA verified: ${CURRENT_SHA:0:12}"

      - name: Checkout PR branch
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          ref: ${{ steps.pr-info.outputs.branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify checkout SHA
        env:
          EXPECTED_SHA: ${{ inputs.head_sha }}
        run: |
          ACTUAL="$(git rev-parse HEAD)"
          if [[ "${ACTUAL,,}" != "${EXPECTED_SHA,,}" ]]; then
            echo "::error::Post-checkout SHA mismatch: ${ACTUAL} ‚â† ${EXPECTED_SHA}"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run remediation guard
        id: guard
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ inputs.pr_number }}
          FINDINGS: ${{ inputs.findings }}
          STRICTNESS: standard
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          DECISION=$(npx tsx scripts/remediation-guard.ts --evaluate)
          {
            echo "decision<<GUARD_EOF"
            echo "$DECISION"
            echo "GUARD_EOF"
          } >> "$GITHUB_OUTPUT"

          SHOULD=$(echo "$DECISION" | jq -r '.shouldRemediate')
          ATTEMPT=$(echo "$DECISION" | jq -r '.attemptNumber')
          REASON=$(echo "$DECISION" | jq -r '.reason')
          echo "should-remediate=${SHOULD}" >> "$GITHUB_OUTPUT"
          echo "attempt=${ATTEMPT}" >> "$GITHUB_OUTPUT"
          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"

          echo "Guard: shouldRemediate=${SHOULD}, attempt=${ATTEMPT}"

      - name: Post guard rejection comment
        if: steps.guard.outputs.should-remediate == 'false'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          DECISION: ${{ steps.guard.outputs.decision }}
          HEAD_SHA: ${{ inputs.head_sha }}
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const headSha = process.env.HEAD_SHA;
            const decision = JSON.parse(process.env.DECISION);
            const marker = `<!-- remediation-blocked: ${headSha} -->`;

            const sections = [
              marker,
              '## üõë Remediation Agent ‚Äî Blocked',
              '',
              `**Reason**: ${decision.reason}`,
              `**Attempt**: ${decision.attemptNumber}`,
              `**SHA**: \`${headSha.slice(0, 12)}\``,
            ];

            if (decision.securityBlockers.length > 0) {
              sections.push('', '### Security Findings (require human review)');
              for (const s of decision.securityBlockers) sections.push(`- ${s}`);
            }

            if (decision.skippedFindings.length > 0) {
              sections.push('', '### Skipped Findings');
              for (const s of decision.skippedFindings) sections.push(`- ${s}`);
            }

            sections.push(
              '',
              '---',
              '*ü§ñ Remediation agent ‚Äî auto-fix blocked.*',
            );

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: sections.join('\n'),
            });

      - name: Build remediation prompt
        if: steps.guard.outputs.should-remediate == 'true'
        id: build-prompt
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          FINDINGS_JSON: ${{ inputs.findings }}
          HEAD_SHA: ${{ inputs.head_sha }}
        with:
          script: |
            const fs = require('fs');

            let template = '';
            try { template = fs.readFileSync('scripts/remediation-agent-prompt.md', 'utf-8'); } catch {}

            let conventions = '';
            try { conventions = fs.readFileSync('KIRO.md', 'utf-8').slice(0, 6000); } catch {}

            let config = '';
            try { config = fs.readFileSync('harness.config.json', 'utf-8'); } catch {}

            const findings = process.env.FINDINGS_JSON;
            const sha = process.env.HEAD_SHA;

            const prompt = [
              template,
              '',
              '## Project Conventions (from KIRO.md)',
              '',
              conventions || 'No KIRO.md found.',
              '',
              '## Harness Configuration',
              '',
              '```json',
              config || '{}',
              '```',
              '',
              '## Findings to Fix',
              '',
              '```json',
              findings,
              '```',
              '',
              `## HEAD SHA: \`${sha}\``,
              '',
              'Fix ONLY the findings listed above. Edit each file directly.',
              'After all fixes, output a JSON object:',
              '```json',
              '{',
              '  "fixed": [{ "file": "path", "finding": "description", "change": "what changed" }],',
              '  "skipped": [{ "file": "path", "finding": "description", "reason": "why" }],',
              '  "filesModified": ["path1", "path2"]',
              '}',
              '```',
            ].join('\n');

            core.setOutput('prompt', prompt);
            core.info(`Prompt built (${prompt.length} chars)`);

      - name: Configure AWS credentials
        if: steps.guard.outputs.should-remediate == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        continue-on-error: true
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Setup Kiro CLI
        if: steps.guard.outputs.should-remediate == 'true'
        uses: clouatre-labs/setup-kiro-action@v1
        with:
          enable-sigv4: 'true'

      - name: Authenticate Kiro CLI
        if: steps.guard.outputs.should-remediate == 'true'
        env:
          KIRO_CLIENT_ID: ${{ secrets.KIRO_CLIENT_ID }}
          KIRO_CLIENT_SECRET: ${{ secrets.KIRO_CLIENT_SECRET }}
          KIRO_REFRESH_TOKEN: ${{ secrets.KIRO_REFRESH_TOKEN }}
          KIRO_PROFILE_ARN: ${{ secrets.KIRO_PROFILE_ARN }}
          KIRO_START_URL: ${{ secrets.KIRO_START_URL || '' }}
          AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
        run: |
          RESPONSE=$(curl -s -X POST \
            "https://oidc.${AWS_REGION}.amazonaws.com/token" \
            -H "Content-Type: application/json" \
            -d "{
              \"grantType\": \"refresh_token\",
              \"clientId\": \"${KIRO_CLIENT_ID}\",
              \"clientSecret\": \"${KIRO_CLIENT_SECRET}\",
              \"refreshToken\": \"${KIRO_REFRESH_TOKEN}\"
            }")
          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.accessToken // empty')
          NEW_REFRESH=$(echo "$RESPONSE" | jq -r '.refreshToken // empty')
          if [[ -z "$ACCESS_TOKEN" ]]; then
            echo "::error::Kiro OIDC token refresh failed"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
            exit 1
          fi
          echo "::add-mask::${ACCESS_TOKEN}"
          echo "::add-mask::${NEW_REFRESH}"
          mkdir -p ~/.local/share/kiro-cli
          EXPIRES_AT=$(date -u -d "+3600 seconds" +"%Y-%m-%dT%H:%M:%S.%6NZ")
          CLIENT_EXPIRES=$(date -u -d "+90 days" +"%Y-%m-%dT%H:%M:%S.000Z")
          python3 -c "
          import sqlite3, json, sys, os, time
          db = os.path.expanduser('~/.local/share/kiro-cli/data.sqlite3')
          conn = sqlite3.connect(db)
          c = conn.cursor()
          c.executescript('''
            CREATE TABLE IF NOT EXISTS migrations (
              id INTEGER PRIMARY KEY, version INTEGER NOT NULL,
              migration_time INTEGER NOT NULL);
            CREATE TABLE IF NOT EXISTS auth_kv (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS state (
              key TEXT PRIMARY KEY, value BLOB);
            CREATE TABLE IF NOT EXISTS history (
              id INTEGER PRIMARY KEY);
            CREATE TABLE IF NOT EXISTS conversations (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS conversations_v2 (
              key TEXT NOT NULL, conversation_id TEXT NOT NULL,
              value TEXT NOT NULL, created_at INTEGER NOT NULL,
              updated_at INTEGER NOT NULL,
              PRIMARY KEY (key, conversation_id));
          ''')
          now = int(time.time())
          for i in range(9):
            c.execute('INSERT OR IGNORE INTO migrations VALUES (?,?,?)', (i+1,i,now))
          token = json.dumps({'access_token': sys.argv[1], 'expires_at': sys.argv[2],
            'refresh_token': sys.argv[3], 'region': sys.argv[6],
            'start_url': sys.argv[7] or '', 'oauth_flow': 'Pkce',
            'scopes': ['codewhisperer:completions','codewhisperer:analysis','codewhisperer:conversations']})
          reg = json.dumps({'client_id': sys.argv[4], 'client_secret': sys.argv[5],
            'client_secret_expires_at': sys.argv[8], 'region': sys.argv[6],
            'oauth_flow': 'Pkce', 'scopes': ['codewhisperer:completions',
            'codewhisperer:analysis','codewhisperer:conversations']})
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:token', token))
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:device-registration', reg))
          if sys.argv[9]:
            profile = json.dumps({'arn': sys.argv[9], 'profile_name': sys.argv[9].split('/')[-1]})
            c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('api.codewhisperer.profile', profile))
          c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('profile.Migrated', '1'))
          conn.commit()
          conn.close()
          " "$ACCESS_TOKEN" "$EXPIRES_AT" "$NEW_REFRESH" \
            "$KIRO_CLIENT_ID" "$KIRO_CLIENT_SECRET" "$AWS_REGION" \
            "$KIRO_START_URL" "$CLIENT_EXPIRES" "$KIRO_PROFILE_ARN"
          kiro-cli-chat whoami

      - name: Run agent
        if: steps.guard.outputs.should-remediate == 'true'
        id: agent
        env:
          KIRO_PROMPT: ${{ steps.build-prompt.outputs.prompt }}
        run: |
          RAW=$(kiro-cli-chat chat --no-interactive --trust-all-tools "$KIRO_PROMPT" 2>&1) || true
          CLEAN=$(printf '%s\n' "$RAW" | sed 's/\x1b\[[0-9;]*m//g')
          echo "$CLEAN"
          JSON_LINE=$(printf '%s\n' "$CLEAN" | python3 -c "
          import sys,json
          t=sys.stdin.read()
          e=t.rfind('}')
          if e>=0:
            d=0
            for i in range(e,-1,-1):
              c=t[i]
              if c=='}':d+=1
              elif c=='{':d-=1
              if d==0:
                try:
                  o=json.loads(t[i:e+1]);print(json.dumps(o))
                except:pass
                break
          " 2>/dev/null || true)
          if [[ -n "$JSON_LINE" ]] && echo "$JSON_LINE" | jq . >/dev/null 2>&1; then
            {
              echo "structured_output<<KIRO_JSON_EOF"
              echo "$JSON_LINE"
              echo "KIRO_JSON_EOF"
            } >> "$GITHUB_OUTPUT"
          fi

      - name: Check for file changes
        if: steps.guard.outputs.should-remediate == 'true'
        id: changes
        run: |
          CHANGED=$(git diff --name-only 2>/dev/null || echo "")
          if [[ -z "$CHANGED" ]]; then
            echo "has-changes=false" >> "$GITHUB_OUTPUT"
            echo "::notice::No files were modified by the remediation agent."
          else
            echo "has-changes=true" >> "$GITHUB_OUTPUT"
            COUNT=$(echo "$CHANGED" | wc -l)
            echo "count=${COUNT}" >> "$GITHUB_OUTPUT"
            {
              echo "files<<FILES_EOF"
              echo "$CHANGED"
              echo "FILES_EOF"
            } >> "$GITHUB_OUTPUT"
            echo "‚úî ${COUNT} file(s) modified"
          fi

      - name: Verify no protected files modified
        if: steps.changes.outputs.has-changes == 'true'
        id: protected
        run: |
          MODIFIED=$(git diff --name-only)
          VIOLATIONS=""

          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            case "$file" in
              .github/workflows/*|harness.config.json|KIRO.md|package-lock.json|package.json|tsconfig.json|eslint.config.js)
                VIOLATIONS="${VIOLATIONS}  - ${file}\n"
                git checkout -- "$file"
                echo "::warning::Reverted protected file: ${file}"
                ;;
            esac
          done <<< "$MODIFIED"

          if [[ -n "$VIOLATIONS" ]]; then
            echo "reverted=true" >> "$GITHUB_OUTPUT"
            echo "::warning::Reverted modifications to protected files."
          else
            echo "reverted=false" >> "$GITHUB_OUTPUT"
          fi

          REMAINING=$(git diff --name-only 2>/dev/null || echo "")
          if [[ -z "$REMAINING" ]]; then
            echo "::notice::No changes remain after reverting protected files."
            echo "has-remaining=false" >> "$GITHUB_OUTPUT"
          else
            echo "has-remaining=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Run validation ‚Äî Lint
        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'
        id: lint
        run: |
          npx eslint src/ --fix 2>/dev/null || true

          if npm run lint; then
            echo "passed=true" >> "$GITHUB_OUTPUT"
          else
            echo "passed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run validation ‚Äî Type Check
        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'
        id: typecheck
        run: |
          if npx tsc --noEmit; then
            echo "passed=true" >> "$GITHUB_OUTPUT"
          else
            echo "passed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run validation ‚Äî Tests
        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'
        id: test
        run: |
          if npm test; then
            echo "passed=true" >> "$GITHUB_OUTPUT"
          else
            echo "passed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Evaluate validation results
        if: steps.changes.outputs.has-changes == 'true' && steps.protected.outputs.has-remaining == 'true'
        id: validation
        env:
          LINT: ${{ steps.lint.outputs.passed }}
          TYPECHECK: ${{ steps.typecheck.outputs.passed }}
          TEST: ${{ steps.test.outputs.passed }}
        run: |
          echo "lint=${LINT}, typecheck=${TYPECHECK}, test=${TEST}"

          if [[ "$LINT" == "true" && "$TYPECHECK" == "true" && "$TEST" == "true" ]]; then
            echo "passed=true" >> "$GITHUB_OUTPUT"
          else
            echo "passed=false" >> "$GITHUB_OUTPUT"
            echo "::warning::Validation failed ‚Äî reverting all remediation changes."
            git checkout -- .
          fi

      - name: Commit and push
        if: steps.validation.outputs.passed == 'true'
        id: commit
        env:
          ATTEMPT: ${{ steps.guard.outputs.attempt }}
          PR_NUMBER: ${{ inputs.pr_number }}
          HEAD_SHA: ${{ inputs.head_sha }}
        run: |
          git config user.name "remediation-bot[bot]"
          git config user.email "remediation-bot[bot]@users.noreply.github.com"

          MODIFIED=$(git diff --name-only)

          git add $MODIFIED

          FILE_COUNT=$(echo "$MODIFIED" | wc -l | tr -d ' ')

          git commit -m "$(printf 'fix: [remediation] auto-fix review finding(s) (attempt %s)\n\nRemediation agent auto-fix for PR #%s.\nSHA: %s\n\nFiles modified: %s\nFiles: %s' "$ATTEMPT" "$PR_NUMBER" "$HEAD_SHA" "$FILE_COUNT" "$(echo "$MODIFIED" | tr '\n' ',')")"

          git push
          NEW_SHA=$(git rev-parse HEAD)
          echo "new-sha=${NEW_SHA}" >> "$GITHUB_OUTPUT"
          echo "‚úî Pushed remediation commit: ${NEW_SHA:0:12}"

      - name: Add remediation attempt label
        if: steps.guard.outputs.should-remediate == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          ATTEMPT: ${{ steps.guard.outputs.attempt }}
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const attempt = parseInt(process.env.ATTEMPT);
            const label = `remediation-attempt-${attempt}`;

            try {
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: label,
                color: 'FFA500',
                description: `Remediation agent attempt ${attempt}`,
              });
            } catch {
            }

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: [label],
            });

            core.info(`Added label: ${label}`);

      - name: Post audit comment
        if: always() && steps.guard.outputs.should-remediate == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          HAS_CHANGES: ${{ steps.changes.outputs.has-changes }}
          CHANGED_FILES: ${{ steps.changes.outputs.files }}
          VALIDATION_PASSED: ${{ steps.validation.outputs.passed }}
          LINT_PASSED: ${{ steps.lint.outputs.passed }}
          TYPECHECK_PASSED: ${{ steps.typecheck.outputs.passed }}
          TEST_PASSED: ${{ steps.test.outputs.passed }}
          NEW_SHA: ${{ steps.commit.outputs.new-sha }}
          ATTEMPT: ${{ steps.guard.outputs.attempt }}
          HEAD_SHA: ${{ inputs.head_sha }}
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const headSha = process.env.HEAD_SHA;
            const attempt = process.env.ATTEMPT;
            const marker = `<!-- remediation-audit: ${headSha} -->`;

            const hasChanges = process.env.HAS_CHANGES === 'true';
            const validationPassed = process.env.VALIDATION_PASSED === 'true';
            const newSha = process.env.NEW_SHA || '';

            const lintOk = process.env.LINT_PASSED === 'true';
            const typecheckOk = process.env.TYPECHECK_PASSED === 'true';
            const testOk = process.env.TEST_PASSED === 'true';

            const statusEmoji = validationPassed && newSha ? '‚úÖ' : hasChanges ? '‚ö†Ô∏è' : 'üí¨';
            const statusText = validationPassed && newSha
              ? 'Fixes Applied'
              : hasChanges
                ? 'Fixes Failed Validation'
                : 'No Changes Made';

            const changedFiles = (process.env.CHANGED_FILES || '').trim();
            const filesSection = changedFiles ? [
              '### Files Modified',
              '',
              ...changedFiles.split('\n').map((f) => `- \`${f}\``),
            ].join('\n') : '';

            const validationSection = hasChanges ? [
              '### Validation',
              '',
              `| Check | Status |`,
              `|-------|--------|`,
              `| Lint | ${lintOk ? '‚úÖ' : '‚ùå'} |`,
              `| Type Check | ${typecheckOk ? '‚úÖ' : '‚ùå'} |`,
              `| Tests | ${testOk ? '‚úÖ' : '‚ùå'} |`,
            ].join('\n') : '';

            const body = [
              marker,
              `## ${statusEmoji} Remediation Agent ‚Äî ${statusText}`,
              '',
              `**Attempt**: ${attempt}`,
              `**Source SHA**: \`${headSha.slice(0, 12)}\``,
              newSha ? `**New SHA**: \`${newSha.slice(0, 12)}\`` : '',
              '',
              filesSection,
              validationSection,
              '',
              '---',
              '*ü§ñ Remediation agent ‚Äî automated code fix.*',
            ].filter(Boolean).join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body,
            });
