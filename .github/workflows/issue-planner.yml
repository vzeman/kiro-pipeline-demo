name: Issue Planner Agent

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to plan'
        required: true
        type: string

permissions:
  issues: write
  contents: read
  actions: write
  id-token: write

concurrency:
  group: issue-planner-${{ github.event.issue.number || inputs.issue_number }}
  cancel-in-progress: true

jobs:
  plan:
    name: Planner Agent
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@39370e3970a6d050c480ffad4ff0ed4d3fdee5af
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Fetch issue JSON (workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        id: fetch-issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUM: ${{ inputs.issue_number }}
        run: |
          ISSUE_DATA=$(gh issue view "$ISSUE_NUM" --json number,title,body,labels,author \
            | jq '{number, title, body, labels, user: {login: .author.login}}')
          {
            echo "json<<ISSUE_EOF"
            echo "$ISSUE_DATA"
            echo "ISSUE_EOF"
          } >> "$GITHUB_OUTPUT"
          echo "Fetched issue #${ISSUE_NUM}"

      - name: Run planner guard
        id: guard
        env:
          ISSUE_JSON: ${{ github.event_name == 'workflow_dispatch' && steps.fetch-issue.outputs.json || toJSON(github.event.issue) }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DECISION=$(npx tsx scripts/issue-planner-guard.ts --evaluate)
          {
            echo "decision<<GUARD_EOF"
            echo "$DECISION"
            echo "GUARD_EOF"
          } >> "$GITHUB_OUTPUT"
          SHOULD=$(echo "$DECISION" | jq -r '.shouldPlan')
          REASON=$(echo "$DECISION" | jq -r '.reason')
          ISSUE_NUM=$(echo "$DECISION" | jq -r '.issueNumber')
          ISSUE_TITLE=$(echo "$DECISION" | jq -r '.issueTitle')
          echo "should-plan=${SHOULD}" >> "$GITHUB_OUTPUT"
          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"
          echo "issue-number=${ISSUE_NUM}" >> "$GITHUB_OUTPUT"
          echo "issue-title=${ISSUE_TITLE}" >> "$GITHUB_OUTPUT"
          echo "Guard: shouldPlan=${SHOULD}, issue=#${ISSUE_NUM}"

      - name: Skip — log reason
        if: steps.guard.outputs.should-plan == 'false'
        run: |
          echo "::notice::Planning skipped: ${{ steps.guard.outputs.reason }}"

      - name: Ensure planner labels exist
        if: steps.guard.outputs.should-plan == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |
            const labels = [
              { name: 'agent:plan', color: '1D76DB', description: 'Approved for automated planning' },
              { name: 'agent:implement', color: '0E8A16', description: 'Approved for automated implementation' },
              { name: 'agent:needs-judgment', color: 'E4E669', description: 'Agent needs human judgment to proceed' },
            ];
            for (const label of labels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ...label,
                });
                core.info(`Created label: ${label.name}`);
              } catch {
                // Label exists
              }
            }

      - name: Read planner prompt
        if: steps.guard.outputs.should-plan == 'true'
        id: prompt-file
        run: |
          if [[ -f ".codefactory/prompts/issue-planner.md" ]]; then
            {
              echo "content<<PROMPT_EOF"
              cat .codefactory/prompts/issue-planner.md
              echo "PROMPT_EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "content=Analyze this issue and produce a structured implementation plan." >> "$GITHUB_OUTPUT"
          fi

      - name: Build planning prompt
        if: steps.guard.outputs.should-plan == 'true'
        id: build-prompt
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          PLANNER_TEMPLATE: ${{ steps.prompt-file.outputs.content }}
          ISSUE_JSON: ${{ github.event_name == 'workflow_dispatch' && steps.fetch-issue.outputs.json || toJSON(github.event.issue) }}
        with:
          script: |
            const fs = require('fs');
            const issue = JSON.parse(process.env.ISSUE_JSON || '{}');
            const template = process.env.PLANNER_TEMPLATE || '';
            let conventions = '';
            try { conventions = fs.readFileSync('KIRO.md', 'utf-8').slice(0, 6000); } catch {}
            let config = '';
            try { config = fs.readFileSync('harness.config.json', 'utf-8'); } catch {}

            const prompt = [
              template,
              '',
              '## Issue to Plan',
              '',
              `**Number**: #${issue.number}`,
              `**Title**: ${issue.title}`,
              `**Author**: ${(issue.user || {}).login || 'unknown'}`,
              '',
              '### Body',
              '',
              issue.body || '*(empty body)*',
              '',
              '## Project Conventions (from KIRO.md)',
              '',
              conventions || 'No KIRO.md found.',
              '',
              '## Harness Configuration',
              '',
              '```json',
              config || '{}',
              '```',
            ].join('\n');

            core.setOutput('prompt', prompt);
            core.info(`Planning prompt built (${prompt.length} chars)`);

      - name: Configure AWS credentials
        if: steps.guard.outputs.should-plan == 'true'
        continue-on-error: true
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Setup Kiro CLI
        if: steps.guard.outputs.should-plan == 'true'
        uses: clouatre-labs/setup-kiro-action@v1
        with:
          enable-sigv4: 'true'

      - name: Authenticate Kiro CLI
        if: steps.guard.outputs.should-plan == 'true'
        env:
          KIRO_CLIENT_ID: ${{ secrets.KIRO_CLIENT_ID }}
          KIRO_CLIENT_SECRET: ${{ secrets.KIRO_CLIENT_SECRET }}
          KIRO_REFRESH_TOKEN: ${{ secrets.KIRO_REFRESH_TOKEN }}
          KIRO_PROFILE_ARN: ${{ secrets.KIRO_PROFILE_ARN }}
          KIRO_START_URL: ${{ secrets.KIRO_START_URL || '' }}
          AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
        run: |
          RESPONSE=$(curl -s -X POST \
            "https://oidc.${AWS_REGION}.amazonaws.com/token" \
            -H "Content-Type: application/json" \
            -d "{
              \"grantType\": \"refresh_token\",
              \"clientId\": \"${KIRO_CLIENT_ID}\",
              \"clientSecret\": \"${KIRO_CLIENT_SECRET}\",
              \"refreshToken\": \"${KIRO_REFRESH_TOKEN}\"
            }")
          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.accessToken // empty')
          NEW_REFRESH=$(echo "$RESPONSE" | jq -r '.refreshToken // empty')
          if [[ -z "$ACCESS_TOKEN" ]]; then
            echo "::error::Kiro OIDC token refresh failed"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
            exit 1
          fi
          echo "::add-mask::${ACCESS_TOKEN}"
          echo "::add-mask::${NEW_REFRESH}"
          mkdir -p ~/.local/share/kiro-cli
          EXPIRES_AT=$(date -u -d "+3600 seconds" +"%Y-%m-%dT%H:%M:%S.%6NZ")
          CLIENT_EXPIRES=$(date -u -d "+90 days" +"%Y-%m-%dT%H:%M:%S.000Z")
          python3 -c "
          import sqlite3, json, sys, os, time
          db = os.path.expanduser('~/.local/share/kiro-cli/data.sqlite3')
          conn = sqlite3.connect(db)
          c = conn.cursor()
          c.executescript('''
            CREATE TABLE IF NOT EXISTS migrations (
              id INTEGER PRIMARY KEY, version INTEGER NOT NULL,
              migration_time INTEGER NOT NULL);
            CREATE TABLE IF NOT EXISTS auth_kv (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS state (
              key TEXT PRIMARY KEY, value BLOB);
            CREATE TABLE IF NOT EXISTS history (
              id INTEGER PRIMARY KEY);
            CREATE TABLE IF NOT EXISTS conversations (
              key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS conversations_v2 (
              key TEXT NOT NULL, conversation_id TEXT NOT NULL,
              value TEXT NOT NULL, created_at INTEGER NOT NULL,
              updated_at INTEGER NOT NULL,
              PRIMARY KEY (key, conversation_id));
          ''')
          now = int(time.time())
          for i in range(9):
            c.execute('INSERT OR IGNORE INTO migrations VALUES (?,?,?)', (i+1,i,now))
          token = json.dumps({'access_token': sys.argv[1], 'expires_at': sys.argv[2],
            'refresh_token': sys.argv[3], 'region': sys.argv[6],
            'start_url': sys.argv[7] or '', 'oauth_flow': 'Pkce',
            'scopes': ['codewhisperer:completions','codewhisperer:analysis','codewhisperer:conversations']})
          reg = json.dumps({'client_id': sys.argv[4], 'client_secret': sys.argv[5],
            'client_secret_expires_at': sys.argv[8], 'region': sys.argv[6],
            'oauth_flow': 'Pkce', 'scopes': ['codewhisperer:completions',
            'codewhisperer:analysis','codewhisperer:conversations']})
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:token', token))
          c.execute('INSERT OR REPLACE INTO auth_kv VALUES (?,?)', ('kirocli:odic:device-registration', reg))
          if sys.argv[9]:
            profile = json.dumps({'arn': sys.argv[9], 'profile_name': sys.argv[9].split('/')[-1]})
            c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('api.codewhisperer.profile', profile))
          c.execute('INSERT OR REPLACE INTO state VALUES (?,?)', ('profile.Migrated', '1'))
          conn.commit()
          conn.close()
          " "$ACCESS_TOKEN" "$EXPIRES_AT" "$NEW_REFRESH" \
            "$KIRO_CLIENT_ID" "$KIRO_CLIENT_SECRET" "$AWS_REGION" \
            "$KIRO_START_URL" "$CLIENT_EXPIRES" "$KIRO_PROFILE_ARN"
          kiro-cli-chat whoami

      - name: Run AI planning analysis
        if: steps.guard.outputs.should-plan == 'true'
        id: ai-plan
        env:
          KIRO_PROMPT: ${{ steps.build-prompt.outputs.prompt }}
        run: |
          RAW=$(kiro-cli-chat chat --no-interactive --trust-all-tools "$KIRO_PROMPT" 2>&1) || true
          CLEAN=$(printf '%s\n' "$RAW" | sed 's/\x1b\[[0-9;]*m//g')
          echo "$CLEAN"
          {
            echo "output<<KIRO_OUTPUT_EOF"
            echo "$CLEAN"
            echo "KIRO_OUTPUT_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Extract plan output
        if: steps.guard.outputs.should-plan == 'true'
        id: extract-plan
        env:
          AGENT_OUTPUT: ${{ steps.ai-plan.outputs.output }}
        run: |
          if [[ -z "$AGENT_OUTPUT" || "$AGENT_OUTPUT" == "null" ]]; then
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "::warning::No plan output received"
          else
            PLAN_TEXT="${AGENT_OUTPUT:0:60000}"
            {
              echo "plan<<PLAN_EOF"
              echo "$PLAN_TEXT"
              echo "PLAN_EOF"
            } >> "$GITHUB_OUTPUT"
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "Extracted plan ($(echo "$PLAN_TEXT" | wc -c) chars)"
          fi

      - name: Post plan comment and dispatch implementer
        if: steps.guard.outputs.should-plan == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          PLAN_TEXT: ${{ steps.extract-plan.outputs.plan || '' }}
          PLAN_FOUND: ${{ steps.extract-plan.outputs.found || 'false' }}
          ISSUE_NUMBER: ${{ steps.guard.outputs.issue-number }}
        with:
          script: |
            const issueNumber = parseInt(process.env.ISSUE_NUMBER, 10);
            const planFound = process.env.PLAN_FOUND === 'true';
            const planOutput = (planFound && process.env.PLAN_TEXT) ? process.env.PLAN_TEXT : '*No plan output received.*';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: [
                `<!-- issue-planner: #${issueNumber} -->`,
                '## Implementation Plan',
                '',
                planOutput,
                '',
                '---',
                '*Issue Planner Agent — automated implementation planning.*',
              ].join('\n'),
            });

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: ['agent:implement'],
            });

            core.info(`Plan posted and agent:implement label added for issue #${issueNumber}`);

      - name: Dispatch implementer workflow
        if: steps.guard.outputs.should-plan == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ steps.guard.outputs.issue-number }}
        run: |
          echo "Dispatching implementer for issue #${ISSUE_NUMBER}..."
          gh workflow run issue-implementer.yml --field issue_number="${ISSUE_NUMBER}"
          echo "Implementer workflow dispatched"

      - name: Failure handler
        if: failure() && steps.guard.outputs.should-plan == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          ISSUE_NUMBER: ${{ steps.guard.outputs.issue-number }}
        with:
          script: |
            const issueNumber = parseInt(process.env.ISSUE_NUMBER, 10);
            try {
              await github.rest.issues.createLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'agent:needs-judgment',
                color: 'E4E669',
                description: 'Agent needs human judgment to proceed',
              });
            } catch {}
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: ['agent:needs-judgment'],
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: [
                `<!-- issue-planner-failed: #${issueNumber} -->`,
                '## Planner Agent Failed',
                '',
                'The planning agent encountered an error while analyzing this issue.',
                'A human should review the failure and decide next steps.',
                '',
                `**Run**: [${context.runId}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
                '',
                '---',
                '*Issue Planner Agent — automated implementation planning.*',
              ].join('\n'),
            });
